# PandaFactor 因子分析引擎文档

## 概述

PandaFactor因子分析引擎是一个专业化的量化投资因子分析系统，提供完整的因子计算、回测、评估和可视化功能。本文档详细介绍了因子分析引擎的架构、功能模块、使用方法和最佳实践。

## 1. 系统架构

### 1.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    因子分析引擎架构                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐     │
│  │  数据输入    │    │  数据处理    │    │  因子分析    │     │
│  │             │    │             │    │             │     │
│  │ • 因子数据   │───▶│ • 数据清洗   │───▶│ • IC分析    │     │
│  │ • 行情数据   │    │ • 标准化     │    │ • 分层回测   │     │
│  │ • 参数配置   │    │ • 中性化     │    │ • 性能评估   │     │
│  └─────────────┘    └─────────────┘    └─────────────┘     │
│                                                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐     │
│  │  结果存储    │    │  可视化      │    │  任务调度    │     │
│  │             │    │             │    │             │     │
│  │ • MongoDB   │◀───│ • 图表生成   │    │ • 异步处理   │     │
│  │ • 分析结果   │    │ • 数据导出   │    │ • 进度监控   │     │
│  │ • 日志记录   │    │ • 报告生成   │    │ • 错误处理   │     │
│  └─────────────┘    └─────────────┘    └─────────────┘     │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 核心模块

| 模块 | 功能 | 文件位置 |
|------|------|---------|
| `factor_analysis.py` | 主分析流程控制器 | `panda_factor/analysis/` |
| `factor.py` | 因子分析核心类 | `panda_factor/analysis/` |
| `factor_func.py` | 数据处理工具函数 | `panda_factor/analysis/` |
| `factor_ic_workflow.py` | IC分析工作流 | `panda_factor/analysis/` |
| `factor_analysis_workflow.py` | 完整分析工作流 | `panda_factor/analysis/` |

## 2. 核心组件详解

### 2.1 factor_analysis.py - 主分析控制器

这是因子分析的主要入口点，负责协调整个分析流程。

#### 主要功能
- 数据获取和验证
- 分析流程控制
- 任务状态管理
- 结果存储

#### 核心函数
```python
def factor_analysis(df_factor: pd.DataFrame, params: Params, 
                   factor_id: str = "", task_id: str = "",
                   logger=logging.Logger) -> None:
    """
    因子分析主函数
    
    参数:
    - df_factor: 因子数据DataFrame
    - params: 分析参数对象
    - factor_id: 因子ID
    - task_id: 任务ID
    - logger: 日志记录器
    """
```

#### 分析流程
1. **数据准备阶段**
   - 获取K线数据
   - 清洗和预处理数据
   - 计算未来收益率

2. **因子处理阶段**
   - 极值处理（3σ或MAD方法）
   - Z-score标准化
   - 数据合并和验证

3. **分组回测阶段**
   - 因子分组
   - 收益率计算
   - 换手率计算

4. **分析评估阶段**
   - IC分析
   - 分层回测
   - 性能指标计算

5. **结果存储阶段**
   - 生成图表数据
   - 保存分析结果
   - 更新任务状态

### 2.2 factor.py - 因子分析核心类

这是因子分析的核心类，封装了完整的因子回测和分析功能。

#### 类结构
```python
class factor:
    def __init__(self, name: str, group_number: int = 10, factor_id: str = None):
        self.name = name                    # 因子名称
        self.factor_id = factor_id          # 因子ID
        self.period = 1                     # 回测周期
        self.predict_direction = 0          # 预测方向
        self.commission = 0.002             # 手续费
        self.group_cnt = group_number       # 分组数量
        
        # 数据存储
        self.df_pnl = pd.DataFrame()        # 收益率矩阵
        self.df_stock = pd.DataFrame()      # 持仓股票矩阵
        self.df_turnover = pd.DataFrame()   # 换手率矩阵
        self.df_ic = pd.DataFrame()         # IC值矩阵
        self.df_info = pd.DataFrame()       # 统计指标矩阵
        self.df_info2 = pd.DataFrame()      # IC统计矩阵
```

#### 核心方法

##### 1. 参数设置
```python
def set_backtest_parameters(self, period: int, predict_direction: int = 0, 
                           commission: float = 0.002, mode: int = 1):
    """
    设置回测参数
    
    参数:
    - period: 回测周期
    - predict_direction: 预测方向(0为反向，1为正向)
    - commission: 手续费
    - mode: 回测模式
    """
```

##### 2. 回测执行
```python
def start_backtest(self, df: pd.DataFrame, df_benchmark_pct: pd.DataFrame):
    """
    开始因子回测
    
    参数:
    - df: 整理好的因子和K线数据
    - df_benchmark_pct: 基准收益率数据
    """
```

##### 3. 性能计算
```python
def cal_turnover_rate(self):
    """计算各组换手率"""
    
def cal_df_info1(self):
    """计算分组统计指标"""
    
def cal_df_info2(self):
    """计算IC统计指标"""
```

##### 4. 可视化方法
```python
def draw_pct(self):
    """绘制分组收益图"""
    
def draw_ic(self, types: int = 0):
    """绘制IC时序图和密度图"""
    
def draw_ic_dacay(self):
    """绘制IC衰减图和自相关图"""
```

##### 5. 数据导出
```python
def return_to_chart_data(self) -> ChartData:
    """导出收益图表数据"""
    
def ic_sequential_to_chart_data(self, ic_type: int = 0) -> ChartData:
    """导出IC时序图表数据"""
    
def inset_to_database(self, factor_id: str = None, task_id=None):
    """保存分析结果到数据库"""
```

### 2.3 factor_func.py - 数据处理工具

提供丰富的数据处理和计算函数。

#### 数据处理函数

##### 1. 收益率计算
```python
def cal_hfq(df: pd.DataFrame) -> pd.DataFrame:
    """
    计算后复权价格和未来收益率
    
    计算1/3/5/10/20/30天的未来收益率
    """
    df['pct'] = df['close'] / df['pre_close'] - 1  # 日收益率
    df['div_factors'] = (1 + df['pct']).cumprod()  # 复权因子
    df['hfq_open'] = df.iloc[0]['open'] * df['div_factors'] / df.iloc[0]['div_factors']
    
    # 计算未来收益率
    df['1day_return'] = df['hfq_open'].shift(-2) / df['hfq_open'].shift(-1) - 1
    df['3day_return'] = df['hfq_open'].shift(-4) / df['hfq_open'].shift(-1) - 1
    df['5day_return'] = df['hfq_open'].shift(-6) / df['hfq_open'].shift(-1) - 1
    df['10day_return'] = df['hfq_open'].shift(-11) / df['hfq_open'].shift(-1) - 1
    df['20day_return'] = df['hfq_open'].shift(-21) / df['hfq_open'].shift(-1) - 1
    df['30day_return'] = df['hfq_open'].shift(-31) / df['hfq_open'].shift(-1) - 1
    
    return df
```

##### 2. 滞后收益率计算
```python
def cal_pct_lag(df: pd.DataFrame) -> pd.DataFrame:
    """
    计算1-20天的滞后收益率
    """
    for i in range(0, 21):
        df[f'returns_lag{i}'] = df.groupby('symbol')['1day_return'].transform(
            lambda x: x.shift(-i))
    return df
```

##### 3. 数据清洗
```python
def clean_k_data(df_k_data: pd.DataFrame) -> pd.DataFrame:
    """
    清洗K线数据，标记无法交易的数据点
    """
    # 标记一字涨停或跌停的股票
    df_k_data['unable_trade'] = np.where(
        (df_k_data['high'] == df_k_data['low']) & 
        ((df_k_data['high'] == df_k_data['limit_up']) | 
         (df_k_data['low'] == df_k_data['limit_down'])), 1, 0)
    
    # 移除不需要的列
    columns_to_drop = ['limit_up', 'limit_down', 'high', 'low', 'volume']
    df_k_data = df_k_data.drop(columns=columns_to_drop)
    
    return df_k_data
```

#### 因子处理函数

##### 1. 极值处理
```python
def ext_out_3std_list(group: pd.DataFrame, factor_list: list, 
                     noise_std: float = 1e-10) -> pd.DataFrame:
    """
    3σ异常值处理并添加噪音确保唯一的分箱边界
    """
    for f in factor_list:
        factor = group[f]
        
        # 添加噪音确保唯一性
        noise = np.random.normal(0, noise_std, size=len(factor))
        factor += noise
        
        # 3σ极值处理
        edge_up = factor.mean() + 3 * factor.std()
        edge_low = factor.mean() - 3 * factor.std()
        factor.clip(lower=edge_low, upper=edge_up, inplace=True)
        
        group[f] = factor
    
    return group
```

##### 2. 标准化
```python
def z_score(group: pd.DataFrame, factor_list: list) -> pd.DataFrame:
    """
    Z-score标准化
    """
    for f in factor_list:
        factor = group[f]
        if factor.std() != 0:
            group[f] = (factor - factor.mean()) / factor.std()
        else:
            group[f] = np.nan
    return group
```

##### 3. 因子分组
```python
def grouping_factor(df: pd.DataFrame, factor_name: str, 
                   group_cnt: int = 10, logger=None) -> tuple:
    """
    因子分组处理
    
    返回:
    - df_cuted: 包含分组信息的DataFrame
    - df_benchmark: 基准收益率DataFrame
    """
    benchmark_pct = {}
    grouped_dfs = []
    
    for date, group in df.groupby('date'):
        # 计算基准收益率
        benchmark_pct_child = {
            '1D_m': group['1day_return'].mean(),
            '3D_m': group['3day_return'].mean(),
            '5D_m': group['5day_return'].mean(),
            '10D_m': group['10day_return'].mean(),
            '20D_m': group['20day_return'].mean(),
            '30D_m': group['30day_return'].mean()
        }
        benchmark_pct[date] = benchmark_pct_child
        
        # 移除无法交易的股票
        group = group[group['unable_trade'] == 0]
        
        if group.empty:
            continue
            
        # 因子分组
        new_group = group.copy()
        if group[factor_name].dropna().nunique() >= group_cnt:
            # 添加噪音确保唯一边界
            noise = np.random.normal(0, 1e-10, size=group[factor_name].dropna().shape)
            noisy_values = group[factor_name].dropna().values + noise
            new_group[f'{factor_name}_group'] = pd.qcut(
                noisy_values, q=group_cnt, labels=range(1, group_cnt + 1))
        
        grouped_dfs.append(new_group)
    
    df_cuted = pd.concat(grouped_dfs) if grouped_dfs else pd.DataFrame()
    df_benchmark = pd.DataFrame(benchmark_pct).T
    
    return df_cuted, df_benchmark
```

## 3. 分析工作流

### 3.1 完整分析工作流 (factor_analysis_workflow.py)

提供完整的因子分析流程，包括数据获取、处理、分析和结果存储。

#### 工作流程
1. **初始化阶段**
   - 加载配置
   - 初始化数据库连接
   - 创建日志记录器

2. **数据获取阶段**
   - 获取因子数据
   - 获取K线数据
   - 数据验证

3. **数据处理阶段**
   - 数据清洗
   - 极值处理
   - 标准化
   - 数据合并

4. **分析执行阶段**
   - 因子分组
   - 回测计算
   - 性能评估

5. **结果存储阶段**
   - 生成图表
   - 保存结果
   - 更新状态

### 3.2 IC分析工作流 (factor_ic_workflow.py)

专门用于IC（信息系数）分析的工作流。

#### IC计算流程
```python
def factor_ic_workflow(df_factor: pd.DataFrame, adjustment_cycle, 
                      group_number, factor_direction):
    """
    IC分析工作流
    
    计算因子的IC值、RankIC等指标
    """
    # 1. 数据准备
    # 2. 因子处理
    # 3. IC计算
    # 4. 结果返回
    
    return result_list  # IC均值列表
```

## 4. 性能指标体系

### 4.1 收益率指标

| 指标 | 计算公式 | 说明 |
|------|----------|------|
| 年化收益率 | `mean(日收益率) * 252` | 年化收益表现 |
| 超额年化 | `mean(超额收益) * 252` | 相对基准的超额收益 |
| 最大回撤 | `max(累计收益最大值 - 当前值)` | 最大亏损幅度 |
| 超额最大回撤 | `max(累计超额收益最大值 - 当前值)` | 超额收益最大回撤 |

### 4.2 风险指标

| 指标 | 计算公式 | 说明 |
|------|----------|------|
| 年化波动率 | `std(日收益率) * sqrt(252)` | 收益率波动程度 |
| 超额年化波动 | `std(超额收益) * sqrt(252)` | 超额收益波动 |
| 跟踪误差 | `sqrt(sum(超额收益²) / (n-1))` | 相对基准的跟踪误差 |
| 夏普比率 | `(年化收益 - 无风险利率) / 年化波动` | 风险调整后收益 |
| 信息比率 | `超额年化 / 超额年化波动` | 超额收益的风险调整指标 |

### 4.3 IC指标

| 指标 | 计算公式 | 说明 |
|------|----------|------|
| IC均值 | `mean(因子值与收益率的相关系数)` | 因子预测能力 |
| IC标准差 | `std(IC值)` | IC稳定性 |
| IC_IR | `IC均值 / IC标准差` | IC的信息比率 |
| Rank_IC | `mean(因子排名与收益率排名的相关系数)` | 排名相关性 |
| 单调性 | `abs(年化收益率排名与分组排名的相关系数)` | 分层单调性 |

## 5. 图表可视化

### 5.1 收益率图表

#### 分组收益图
```python
def return_to_chart_data(self) -> ChartData:
    """
    生成分组收益图表数据
    
    包含各分组的累计收益率曲线
    """
    # 准备数据
    dates = self.df_ic.index.tolist()
    x_data = [SeriesItem(name="date", data=date_strs)]
    y_data = []
    
    # 各分组收益数据
    for group_idx in range(1, self.group_cnt + 1):
        y_data.append(SeriesItem(
            name=f'组{group_idx}',
            data=self.df_pnl[f'group{group_idx}_pnl'].cumsum().tolist()
        ))
    
    # 多空组合数据
    y_data.append(SeriesItem(
        name=f'多空组合',
        data=self.df_pnl['group_ls'].cumsum().tolist()
    ))
    
    return ChartData(title=f'{self.name} 分组收益', x=x_data, y=y_data)
```

#### 超额收益图
```python
def excess_return_to_chart_data(self) -> ChartData:
    """
    生成超额收益图表数据
    """
    # 类似分组收益图，但使用超额收益率
```

### 5.2 IC分析图表

#### IC时序图
```python
def ic_sequential_to_chart_data(self, ic_type: int = 0) -> ChartData:
    """
    生成IC时序图数据
    
    参数:
    - ic_type: 0为普通IC，1为RankIC
    """
    ic_value = self.df_ic['rank_ic'] if ic_type else self.df_ic['ic']
    mu = float(ic_value.mean())
    sigma = float(ic_value.std())
    
    title = f'{self.name} Rank_IC={str_round(mu, 3)} IC_IR={str_round(mu/sigma, 4)}'
    
    x_data = [SeriesItem(name="date", data=date_strs)]
    y_data = [
        SeriesItem(name="IC", data=ic_value.fillna(0).tolist()),
        SeriesItem(name="Cum_IC", data=ic_value.fillna(0).cumsum().tolist())
    ]
    
    return ChartData(title=title, x=x_data, y=y_data)
```

#### IC密度图
```python
def ic_density_to_chart_data(self, ic_type: int = 0) -> ChartData:
    """
    生成IC密度分布图数据
    """
    ic_value = self.df_ic['rank_ic'] if ic_type else self.df_ic['ic']
    mu = np.mean(ic_value)
    sigma = np.std(ic_value)
    
    # 直方图数据
    n, bins = np.histogram(ic_value, bins=60, density=True)
    y = norm.pdf(bins, mu, sigma)
    
    x_data = [SeriesItem(name="IC", data=bins.tolist())]
    y_data = [
        SeriesItem(name="Density", data=n.tolist()),
        SeriesItem(name="Normal", data=y.tolist())
    ]
    
    return ChartData(title=f'{self.name} IC分布', x=x_data, y=y_data)
```

#### IC衰减图
```python
def ic_decay_to_chart_data(self, ic_type: int = 0) -> ChartData:
    """
    生成IC衰减图数据
    """
    ic_col = 'rank_ic' if ic_type else 'ic'
    
    # 准备滞后期数据
    lags = [0]
    ic_values = [float(self.df_ic[ic_col].mean())]
    
    for i in range(1, 21):
        lag_column = f'{ic_col}_lag{i}'
        if lag_column in self.df_ic.columns:
            lags.append(i)
            ic_values.append(float(self.df_ic[lag_column].mean()))
    
    title = f'{self.name} Rank IC衰减图' if ic_type else f'{self.name} IC衰减图'
    
    return ChartData(
        title=title,
        x=[SeriesItem(name="滞后期数", data=lags)],
        y=[SeriesItem(name="IC值", data=ic_values)]
    )
```

## 6. 数据模型

### 6.1 分析参数模型

```python
class Params:
    """因子分析参数模型"""
    def __init__(self):
        self.start_date: str = ""           # 开始日期
        self.end_date: str = ""             # 结束日期
        self.adjustment_cycle: int = 1       # 调仓周期
        self.factor_direction: int = 0       # 因子方向
        self.group_number: int = 10         # 分组数量
        self.extreme_value_processing: str = "std"  # 极值处理方法
        self.stock_pool: str = "000985"     # 股票池
        self.include_st: bool = True        # 是否包含ST股票
```

### 6.2 图表数据模型

```python
class ChartData:
    """图表数据模型"""
    def __init__(self, title: str, x: List[SeriesItem], y: List[SeriesItem]):
        self.title = title                  # 图表标题
        self.x = x                         # X轴数据
        self.y = y                         # Y轴数据

class SeriesItem:
    """数据序列项"""
    def __init__(self, name: str, data: List):
        self.name = name                    # 序列名称
        self.data = data                   # 数据列表
```

### 6.3 分析结果存储结构

```javascript
// MongoDB集合: factor_analysis_results
{
  "_id": ObjectId,
  "task_id": "任务ID",
  "factor_name": "因子名称",
  "factor_id": "因子ID",
  "created_at": "创建时间",
  "updated_at": "更新时间",
  "period": 1,                        // 回测周期
  "pred_direction": 0,                 // 预测方向
  "commission": 0.002,                 // 手续费
  "mode": 1,                          // 回测模式
  
  // 图表数据
  "return_chart": ChartData,           // 收益图数据
  "excess_chart": ChartData,           // 超额收益图数据
  "ic_seq_chart": ChartData,           // IC时序图数据
  "rank_ic_seq_chart": ChartData,      // RankIC时序图数据
  "ic_den_chart": ChartData,           // IC密度图数据
  "rank_ic_den_chart": ChartData,      // RankIC密度图数据
  "ic_decay_chart": ChartData,         // IC衰减图数据
  "rank_ic_decay_chart": ChartData,    // RankIC衰减图数据
  "ic_self_correlation_chart": ChartData,  // IC自相关图数据
  "rank_ic_self_correlation_chart": ChartData, // RankIC自相关图数据
  "simple_return_chart": ChartData,    // 简单收益图数据
  
  // 分析结果
  "one_group_data": {},                // 单组性能数据
  "last_date_top_factor": [],          // 最新日期TOP20因子值
  "group_return_analysis": [],         // 分组收益分析
  "factor_data_analysis": []           // 因子数据分析
}
```

## 7. 使用指南

### 7.1 基本使用流程

#### 1. 准备数据
```python
import pandas as pd
from panda_common.models.factor_analysis_params import Params
from panda_factor.analysis.factor_analysis import factor_analysis

# 准备因子数据
df_factor = pd.DataFrame({
    'date': ['20240101', '20240101', '20240102', '20240102'],
    'symbol': ['000001.SZ', '000002.SZ', '000001.SZ', '000002.SZ'],
    'factor_value': [1.5, 2.3, 1.6, 2.4]
})

# 设置分析参数
params = Params()
params.start_date = "2024-01-01"
params.end_date = "2024-12-31"
params.adjustment_cycle = 5
params.group_number = 10
params.factor_direction = 1
```

#### 2. 执行分析
```python
# 执行因子分析
factor_analysis(
    df_factor=df_factor,
    params=params,
    factor_id="test_factor",
    task_id="task_001",
    logger=logger
)
```

#### 3. 获取结果
```python
from panda_common.handlers.database_handler import DatabaseHandler
from panda_common.config import config

# 查询分析结果
db_handler = DatabaseHandler(config)
results = db_handler.mongo_find(
    "panda", 
    "factor_analysis_results",
    {"factor_id": "test_factor"}
)

if results:
    result = results[0]
    print(f"分析完成: {result['factor_name']}")
    print(f"IC均值: {result['factor_data_analysis'][0]['IC_mean']}")
```

### 7.2 高级使用

#### 1. 自定义分析流程
```python
from panda_factor.analysis.factor import factor

# 创建因子对象
factor_obj = factor("custom_factor", group_number=5)

# 设置回测参数
factor_obj.set_backtest_parameters(
    period=10,
    predict_direction=1,
    commission=0.003
)

# 执行回测
factor_obj.start_backtest(df_cuted, df_benchmark)

# 生成图表
return_chart = factor_obj.return_to_chart_data()
ic_chart = factor_obj.ic_sequential_to_chart_data()

# 保存结果
factor_obj.inset_to_database()
```

#### 2. 批量因子分析
```python
def batch_factor_analysis(factor_list, params):
    """批量因子分析"""
    results = []
    
    for factor_name in factor_list:
        try:
            # 获取因子数据
            df_factor = get_factor_data(factor_name)
            
            # 执行分析
            factor_analysis(df_factor, params, factor_name)
            
            # 记录结果
            results.append({"factor": factor_name, "status": "success"})
            
        except Exception as e:
            results.append({"factor": factor_name, "status": "failed", "error": str(e)})
    
    return results
```

## 8. 最佳实践

### 8.1 数据质量保证

1. **数据验证**
   - 检查数据完整性
   - 验证数据格式
   - 处理缺失值

2. **异常处理**
   - 极值处理
   - 异常值检测
   - 数据清洗

3. **标准化处理**
   - Z-score标准化
   - 行业中性化
   - 市值中性化

### 8.2 分析参数优化

1. **分组数量选择**
   - 根据股票数量调整
   - 考虑统计显著性
   - 平衡粒度和稳定性

2. **回测周期设置**
   - 短期因子：1-5天
   - 中期因子：5-20天
   - 长期因子：20-60天

3. **极值处理方法**
   - 3σ方法：适用于正态分布
   - MAD方法：适用于非正态分布
   - 百分位法：适用于极端分布

### 8.3 性能优化

1. **计算优化**
   - 使用向量化操作
   - 避免循环计算
   - 合理使用缓存

2. **内存管理**
   - 分批处理大数据
   - 及时释放内存
   - 使用高效数据结构

3. **并行处理**
   - 多因子并行分析
   - 异步任务处理
   - 分布式计算

## 9. 故障排除

### 9.1 常见问题

| 问题 | 原因 | 解决方案 |
|------|------|---------|
| 数据不足 | 时间范围过短或股票池太小 | 扩大时间范围或增加股票池 |
| 分组失败 | 因子值唯一性不足 | 检查因子计算，增加噪音 |
| IC计算异常 | 收益率数据缺失 | 检查K线数据完整性 |
| 内存溢出 | 数据量过大 | 分批处理或增加内存 |

### 9.2 调试工具

```python
# 数据检查
def check_data_quality(df):
    """检查数据质量"""
    print(f"数据形状: {df.shape}")
    print(f"缺失值统计: {df.isnull().sum()}")
    print(f"数据类型: {df.dtypes}")
    
    # 检查因子值分布
    factor_cols = [col for col in df.columns if col not in ['date', 'symbol']]
    for col in factor_cols:
        print(f"{col} 统计: {df[col].describe()}")

# 分析进度监控
def monitor_analysis_progress(task_id):
    """监控分析进度"""
    db_handler = DatabaseHandler(config)
    task = db_handler.mongo_find("panda", "tasks", {"task_id": task_id})
    
    if task:
        print(f"任务状态: {task[0]['process_status']}")
        print(f"更新时间: {task[0]['updated_at']}")
```

## 10. 扩展开发

### 10.1 新增分析指标

```python
def calculate_custom_metrics(df_pnl, df_ic):
    """计算自定义指标"""
    # 示例：计算胜率
    win_rate = (df_pnl['group_ls'] > 0).mean()
    
    # 示例：计算最大连续亏损
    cum_returns = df_pnl['group_ls'].cumsum()
    max_consecutive_loss = 0
    current_loss = 0
    
    for ret in cum_returns:
        if ret < 0:
            current_loss += 1
            max_consecutive_loss = max(max_consecutive_loss, current_loss)
        else:
            current_loss = 0
    
    return {
        'win_rate': win_rate,
        'max_consecutive_loss': max_consecutive_loss
    }
```

### 10.2 新增图表类型

```python
def create_correlation_heatmap(factor_data):
    """创建因子相关性热力图"""
    correlation_matrix = factor_data.corr()
    
    # 转换为图表数据
    chart_data = ChartData(
        title="因子相关性热力图",
        x=[SeriesItem(name="因子", data=correlation_matrix.columns.tolist())],
        y=[SeriesItem(name="相关性", data=correlation_matrix.values.tolist())]
    )
    
    return chart_data
```

## 总结

PandaFactor因子分析引擎提供了完整的因子分析解决方案，从数据处理到结果可视化的全流程支持。通过模块化设计和丰富的功能接口，系统能够满足不同层次的因子分析需求，为量化投资研究提供强有力的工具支持。

系统的优势在于：
- **完整性**：覆盖因子分析全流程
- **灵活性**：支持多种分析参数和配置
- **可扩展性**：模块化设计便于功能扩展
- **实用性**：丰富的图表和指标体系
- **稳定性**：完善的错误处理和日志记录

通过遵循本文档的指导，用户可以充分利用因子分析引擎的功能，开展高质量的量化因子研究工作。